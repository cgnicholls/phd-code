// This is the correct version for computing quintics.

// Let T be a 5-torsion point. We work with the subspace of quartics in ki
// generated by q_{ijklm}(D) = k_i(D) * B_{jk}(D, T) * B_{lm}(D, 2T), where
// i,j,k,l,m in {1,2,3,4}.

// For fixed i,j,k,l,m, we compute the sum over the S5-orbit of i,j,k,l,m of
// q_{ijklm}(D).

load "biquadraticforms.m";

// Computes the biquadratic form B_{ij} at the Kummer coordinates kA and kB.
compute_B_ij := function(kA, kB, ii, jj)
    return hom<P->P | specialiseToFHom(ffs), kA cat kB>(BBB[ii,jj]);
end function;
    
// kD should be the Kummer coordinates of a general point.
// kT should be the Kummer coordinates of T, where T is 5-torsion.
// k2T should be the Kummer coordinates of 2T.
// ijklm should be a list of length 5, with each value in the range 1..4.
// This computes k_i(D) * B_{jk}(D, T) * B_{lm}(D, 2T).
compute_q_ijklm := function(kD, kT, k2T, ijklm)
    i := ijklm[1];
    j := ijklm[2];
    k := ijklm[3];
    l := ijklm[4];
    m := ijklm[5];
    return kD[i] * compute_B_ij(kD, kT, j, k) * compute_B_ij(kD, k2T, l, m);
end function;

// Computes the sum over the S5-orbit of ijklm of q_ijklm. Note that S5 acts on
// the order (i,j,k,l,m), not on the individual indices.
compute_q_orbit := function(kD, kT, k2T, ijklm)
    indices := [[ijklm[i^g] : i in [1..5]] : g in SymmetricGroup(5)];
    result := 0;
    for index in indices do
        result +:= compute_q_ijklm(kD, kT, k2T, index);
    end for;
    return result;
end function;

// Returns all lists of length 'length' that can be made from the elements
// 'elts'.
all_lists_with_repeats := function(length, elts)
    current_lists := [[]];
    for l in [1..length] do
        next_lists := [];
        for list in current_lists do
            for elt in elts do
                Append(~next_lists, list cat [elt]);
            end for;
        end for;
        current_lists := next_lists;
    end for;
    return current_lists;
end function;

// Compute the space of quintics generated by q_ijklm that are invariant under
// translation by T, where kT are the Kummer coords of the 5-torsion point T.
compute_invariant_quintics := function(kD, kT, k2T)
    // We could just use all ijklms, which would give 1024 to compute. But
    // instead we can reduce this to 56 by seeing which ones give different
    // orbits.
    all_ijklms := all_lists_with_repeats(5, [1,2,3,4]);    
    ijklms := [];
    index_sets_so_far := [];
    for ijklm in all_ijklms do
        indices_ijlkm := [[ijklm[i^g] : i in [1..5]] : g in SymmetricGroup(5)];
        if not Set(indices_ijlkm) in index_sets_so_far then
            Append(~ijklms, ijklm);
            Append(~index_sets_so_far, Set(indices_ijlkm));
        end if;
    end for;
    print "Number of ijklms", #ijklms;
    quintics := [compute_q_orbit(kD, kT, k2T, ijklm) : ijklm in ijklms];
    return quintics;
end function;

print "Compute the invariant quintics for T1 and for T2 separately";
time quintics_T1 := compute_invariant_quintics([k1,k2,k3,k4], Q1ki, Q1Q1ki);
time quintics_T2 := compute_invariant_quintics([k1,k2,k3,k4], Q2ki, Q2Q2ki);

print "Reduce the quintics by the Kummer equation";
time quintics_T1 := reduceall(quintics_T1, kummeqn);
time quintics_T2 := reduceall(quintics_T2, kummeqn);

print "Compute the subspace of polynomials quintics_T1 and quintics_T2";
monomials_ki_deg_5 := degreencombinations([k1,k2,k3,k4], 5);

time quintics_T1_subspace, V := subspaceOfPolys(quintics_T1, monomials_ki_deg_5);
time quintics_T2_subspace, V := subspaceOfPolys(quintics_T2, monomials_ki_deg_5);

print "Dimensions of T1 and T2 subspaces:", Dimension(quintics_T1_subspace), Dimension(quintics_T2_subspace);

print "Compute the intersection. This is the subspace invariant under
translation by both T1 and T2.";
time invariant_subspace := quintics_T1_subspace meet quintics_T2_subspace;

// At this point we have found the space of invariant quintics. We can call them
// l1, l2, l3, l4. We now just need to find the unique quartic satisfied by
// them. We first want to linearly transform so that the quartic is of the form
// l4^2 * (l2^2 - 4*l1*l3) + O(l4).

invariant_basis := Basis(invariant_subspace);

r1 := vectorToPolynomial(invariant_basis[1], monomials_ki_deg_5);
r2 := vectorToPolynomial(invariant_basis[2], monomials_ki_deg_5);
r3 := vectorToPolynomial(invariant_basis[3], monomials_ki_deg_5);
r4 := vectorToPolynomial(invariant_basis[4], monomials_ki_deg_5);

print("First diagonalise the ri to get li. Then li has leading term ki * k4^4
(i=1..4)");
M := Matrix([[MonomialCoefficient(ri, mon) : mon in [k1*k4^4, k2*k4^4, k3*k4^4,
k4^5]] : ri in [r1,r2,r3,r4]]);

li := ChangeRing(M^-1, P) * Matrix([[r1],[r2],[r3],[r4]]);

ll1 := li[1][1];
ll2 := li[2][1];
ll3 := li[3][1];
ll4 := li[4][1];

print "Reducing lli";
lli := reduceall([ll1,ll2,ll3,ll4], kummeqn);

// Print the lli to file.
PrintFile("lli.m", lli);

print "Compute quartics in ll1, ..., ll4 and their linear relations";
time quartics_li := degreencombinations([ll1,ll2,ll3,ll4], 4);
print "Reducing";
time reducedquartics := reduceall(quartics_li, kummeqn);

