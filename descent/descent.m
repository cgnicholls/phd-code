intrinsic LocaliseProduct(As::SetCart, Aps::SetCart, elt::Tup) -> Tup
{ Takes a list representing an element in the direct product of As and localises
the elements, returning a list representing an element of the direct product of Aps. }
    return Aps!<hom<As[i]->Aps[i] | Aps[i].1>(elt[i]) : i in [1..#Components(Aps)]>;
end intrinsic;


intrinsic ComputeSelmerTriple(local_selmer_map::Map, pair::Tup) -> SeqEnum
{ Given an element of the Cartesian product <J, As>, we apply local_selmer_map to get an
element of the Cartesian product <J, Aps, local_selmer>. }
    J := Parent(pair)[1];
    As := Parent(pair)[2];
    Aps := Domain(local_selmer_map);
    local_selmer := Codomain(local_selmer_map);
    triple := car<J, Aps, local_selmer>;
    local_element := LocaliseProduct(As, Aps, pair[2]);
    return triple!<pair[1], local_element, local_selmer_map(local_element)>;
end intrinsic;


intrinsic ComputeSelmerTriple(cassels_map::Map, selmer_map::Map, pt::JacHypPt) -> Tup
{ }
    J := Parent(pt);
    algebras := Codomain(cassels_map);
    selmer := Codomain(selmer_map);
    triple := car<J, algebras, selmer>;
    cassels_image := cassels_map(pt);
    selmer_image := selmer_map(cassels_image);
    return triple!<pt, cassels_image, selmer_image>;
end intrinsic;


intrinsic ComputeLocalPoints(data::. : bound:=100, precision:=100) -> .
{ Computes enough local points to meet the bound. Searches for points on J
and Jd, the Jacobians of y^2 = f, y^2 = fd, respectively. The image under
the Cassels map is expected to have size 'expected_size', so we search with
increasing height bounds until we hit this size. Note that some of the image
under the Cassels maps can come from the global points. We return the used_global_points,
used_global_pointsd.

data should be a list consisting of [* f, fd, m, p, As, Ads,
    cassels_map, cassels_mapd, expected_size, global_pairs, global_pairsd *].

fields should be a Cartesian product of fields.

Returns gens, gensd, selmer_data, selmer_datad, local_triples, local_triplesd, global_triples, global_triplesd.
}
    // TODO: Currently requires Cassels maps to be injective.
    f := data[1];
    fd := data[2];
    m := data[3];
    p := data[4];
    As := data[5];
    Ads := data[6];
    cassels_map := data[7];
    cassels_mapd := data[8];
    expected_size := data[9];
    global_pairs := data[10];
    global_pairsd := data[11];

    // Compute the local m-Selmer group for each field
    m_selmer, m_selmer_map, Aps := ComputeMSelmerGroupLocal(p, m, As);
    m_selmerd, m_selmer_mapd, Adps := ComputeMSelmerGroupLocal(p, m, Ads);

    J := Jacobian(HyperellipticCurve(f));
    Jd := Jacobian(HyperellipticCurve(fd));

    global_triples := TryToCompute(func<pair | ComputeSelmerTriple(m_selmer_map, pair)>, global_pairs);
    global_triplesd := TryToCompute(func<pair | ComputeSelmerTriple(m_selmer_mapd, pair)>, global_pairsd);

    indices := IndicesGeneratingSubgroup([trip[3] : trip in global_triples], m_selmer);
    indicesd := IndicesGeneratingSubgroup([trip[3] : trip in global_triplesd], m_selmerd);
    global_triples := global_triples[indices];
    global_triplesd := global_triplesd[indicesd];

    // Compute the subgroups generated by the global images.
    subgp := sub<m_selmer | [trip[3] : trip in global_triples]>;
    subgpd := sub<m_selmerd | [trip[3] : trip in global_triplesd]>;
    print "Image of global size:", #subgp;
    print "Image of global size d:", #subgpd;

    // Find the local points. This computes generators for J'(Qp).
    Qp := pAdicField(p, precision);

    // First compute the subgroup generated by the global points.
    J := Jacobian(HyperellipticCurve(f));
    Jd := Jacobian(HyperellipticCurve(fd));
    Jp := BaseChange(J, Qp);
    Jdp := BaseChange(Jd, Qp);

    current_bound := 10;
    gens := [];
    gensd := [];

    local_triples := [];
    local_triplesd := [];
    used_global_images := [trip[3] : trip in global_triples];
    used_global_imagesd := [trip[3] : trip in global_triplesd];

    while (#subgp * #subgpd lt expected_size) and (current_bound le bound) do
        print "Searching with bound", current_bound, "for p = ", p;

        // Search local points on both Jacobians.
        local_points := IndexedSetToSequence(SearchLocalPointsOnJacobian(f, Qp : Bound:=current_bound));
        local_pointsd := IndexedSetToSequence(SearchLocalPointsOnJacobian(fd, Qp : Bound:=current_bound));

        local_triples := TryToCompute(func<pt | ComputeSelmerTriple(cassels_map, m_selmer_map, pt)>, local_points);
        local_triplesd := TryToCompute(func<pt | ComputeSelmerTriple(cassels_mapd, m_selmer_mapd, pt)>, local_pointsd);

        print "Number of local triples, local triples d", #local_triples, #local_triplesd;

        indices := IndicesGeneratingSubgroup([trip[3] : trip in local_triples], m_selmer :
            start_with := used_global_images);
        indicesd := IndicesGeneratingSubgroup([trip[3] : trip in local_triplesd], m_selmerd :
            start_with := used_global_imagesd);
        local_triples := local_triples[indices];
        local_triplesd := local_triplesd[indicesd];

        // Compute the subgroups generated by the images.
        subgp := sub<m_selmer | used_global_images cat [trip[3] : trip in local_triples]>;
        subgpd := sub<m_selmerd | used_global_imagesd cat [trip[3] : trip in local_triplesd]>;

        print "Sizes:", #subgp, #subgpd, ". Expected size:", expected_size;

        print "Current bound", current_bound;
        current_bound *:= 2;
    end while;

    // Get the generators.
    gens := Generators(subgp);
    gensd := Generators(subgpd);

    // TODO: Fix this -- the computed size is sometimes larger than the expected size.
    // We expect the size of the product to be expected_size.
    assert #subgp * #subgpd eq expected_size;

    return gens, gensd, m_selmer_map, m_selmer_mapd,
        local_triples, local_triplesd, global_triples, global_triplesd;
end intrinsic;


intrinsic ComputePreimage(the_map::Map, subgroup::GrpAb) -> GrpAb
{ Let the_map be a map from gp1 to gp2. Let subgroup be a subgroup of gp2. 
This function computes the preimage of subgroup in gp1. }
    kernel := Kernel(the_map);
    kernel_gens := [gen : gen in Generators(kernel)];

    // First restrict the subgroup to the image of the map.
    subgroup_meet_image := Image(the_map) meet subgroup;
    preimages := [gen @@ the_map : gen in Generators(subgroup_meet_image)];
    return sub<Domain(the_map) | kernel_gens cat preimages>;
end intrinsic;


intrinsic IntersectLocalInformation(global_selmer_map::Map, local_selmer_map::Map,
    local_selmer_images::SeqEnum) -> GrpAb
{ }
    As := Domain(global_selmer_map);
    global_selmer := Codomain(global_selmer_map);
    Aps := Domain(local_selmer_map);
    local_selmer := Codomain(local_selmer_map);
    // Compute the right vertical map.
    rv_map := ComputeRightVerticalMap(global_selmer_map, local_selmer_map);

    // Compute the subgroup of the local Selmer group.
    local_selmer_images := sub<local_selmer | local_selmer_images>;

    // Return the preimage.
    return ComputePreimage(rv_map, local_selmer_images);
end intrinsic;


intrinsic ComputeRankBoundFromSelmer(m::RngIntElt, selmer_size::RngIntElt, torsion_size::RngIntElt) -> RngIntElt
{ Computes the maximal r such that m^r <= selmer_size / torsion_bound. }
    return Floor(Log(m, selmer_size / torsion_size));
end intrinsic;